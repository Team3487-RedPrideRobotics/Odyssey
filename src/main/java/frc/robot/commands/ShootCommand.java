// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.commands;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants;
import frc.robot.subsystems.Manipulator;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class ShootCommand extends CommandBase {
	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	
	private final Double m_speed;
	
	private final Double m_angle;
	
	private final Manipulator manipulator;
	private boolean shooting = false;
	
	private boolean firstPass = true;
	
	private final Timer timer;
	
	private boolean finished = false;
	
	private final double m_shoot_speed;
	
	public ShootCommand(Double angle, Double speed, Double shoot_speed, Manipulator m_manipulator) {
		m_angle = angle;
		m_speed = speed;
		m_shoot_speed = shoot_speed;
		manipulator = m_manipulator;
		timer = new Timer();
	}
	
	// Called when the command is initially scheduled.
	@Override
	public void initialize() {
		manipulator.deployResetEncoder();
	}
	
	// Called every time the scheduler runs while the command is scheduled.
	@Override
	public void execute() {
		if (m_speed < 0) {
			if (manipulator.deployGetPosition() >= m_angle) {
				manipulator.deploySetSpeed(-m_speed);
			}
			else {
				manipulator.deploySetVoltage(Constants.ManipulatorConstants.deployIdleVoltage);
				shooting = true;
			}
		}
		else if (m_speed > 0) {
			if (manipulator.deployGetPosition() <= m_angle) {
				manipulator.deploySetSpeed(m_speed);
			}
			else {
				manipulator.deploySetVoltage(Constants.ManipulatorConstants.deployIdleVoltage);
				shooting = true;
			}
		}
		else {
			shooting = true;
			manipulator.deploySetVoltage(Constants.ManipulatorConstants.deployIdleVoltage);
		}
		if (shooting == true) {
			if (m_shoot_speed == 0) {
				finished = true;
			}
			else {
				manipulator.revSetSpeed(0.5);
				if (manipulator.revGetSpeed() >= 390) {
					manipulator.inputSetSpeed(-m_shoot_speed);
					if (firstPass) {
						timer.start();
						firstPass = false;
					}
					else if (timer.get() <= 2) {
						finished = true;
						manipulator.revSetSpeed(0);
						manipulator.inputSetSpeed(0);
					}
				}
			}
		}
	}
	
	// Called once the command ends or is interrupted.
	@Override
	public void end(boolean interrupted) {
	}
	
	// Returns true when the command should end.
	@Override
	public boolean isFinished() {
		return finished;
	}
	
	@Override
	public boolean runsWhenDisabled() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
		return false;
		
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
	}
}
